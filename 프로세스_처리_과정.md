## 프로세스_처리_과정

폰노이만 구조에서 프로그램이 실행되기 위해서는 해당 코드가 메모리에 적재되어야 한다. 이때 실행된 프로그램을 프로세스라 하는데, 운영체제에서 프로세스는 하나의 작업 단위가 된다.

### 프로그램에서 프로세스로의 전환

<img width="317" alt="image" src="https://user-images.githubusercontent.com/51963264/193565297-6dffa207-e784-4772-a258-bdb240d32360.png">


프로그램에서 프로세스로 전환될 때 몇가지 과정을 거친다.    

1) 프로세스 식별자를 결정한다
2) 프로세스 작업을 위한 메모리 공간을 확보하는 동시에 `프로세스제어블록(PCB)`공간을 할당한다
3) PCB을 초기화한다
4) 준비 큐에 삽입한다

### 프로세스의 상태

<img width="639" alt="image" src="https://user-images.githubusercontent.com/51963264/193568541-9ed6a9d7-5e6b-4de9-a0ed-925cff4469c1.png">


현대 운영체제는 시분할 방식을 채택하고 있기 때문에 작업의 효율화를 위헤 CPU를 점유중인 프로세스가 중간에 다른 프로세스에게 CPU를 넘겨주는 일이 빈번하다. 이것을 상황별 프로세스의 상태로 나누어 설명할 수 있다.

`생성상태 create status`

프로세스가 메모리에 올랑와 운영체제로부터 제어 블록을 할당 받은 상태를 말한다. 생성된 프로세스는 바로 실행되지 않고 준비 상태에서 자기 순서를 기다린다.

`준비 상태 ready status`

프로세스가 실행되기 위해 대기중인 상태를 말한다. PCB은 준비 큐에서 기다리며 CPU스케쥴러에의해 관리된다. CPU스케쥴러는 dispatch 제어블록을 선택하는데 이말은 dispatch를 통해 준비상태 프로세스는 실행상태가 된다.

`실행 상태 execute status`

프로세스가 CPU를 할당받아 실행된 상태를 말한다. 이때 정해진 시간만큼 작업을 수행할수 있는데 정해진 시간이 지나도 작업이 완료되지 않으면 다시 준비 상태로 돌아간다. 만약 입출력 요청이 발생하면 해당 프로세스는 대기 상태가 된다.

`대기 상태 block status`

프로세스는 대기 상태를 뺀 4가지 상태로도 작업을 진행하는데 큰 지장이 없다. 하지만 효율성 측면에서 대기 상태를 추가하는 것이 유리한데, 프로세스가 입출력을 요구할 경우, 대기 상태가 없다면 CPU는 다른 일을 하지 않고 입출력 작업이 완료될때까지 대기 하게 된다. 대기 상태의 프로세스는 입출력별로 마련된 큐에서 기다려며 입출력 작업이 완료되면 인터럽트가 발생하고 준비상태로 돌아간다.

`완료 상태 terminate status`

프로세스가 종료된 상태를 말한다. 완료상태에서는 코드와 테이터를 메모리에서 지우고 PCB을 폐기한다. 만약 비정상적으로 종료된 경우 종료 직전 메모리 상태를 저장장치에 기록하게 되는데 이를 코어 덤프라고 한다. 이를 통해 오류 원인을 쉽게 파악할 수 있다.
