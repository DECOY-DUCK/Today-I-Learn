## 병행 제어

DBMS는 여러 사용자가 동시에 데이터를 공유할 수 있도록 한다. 만약 데이터 변경이 일어날 경우 문제가 발생할 수 있기 때문에 여러 병행 제어 기법을 통해 이 문제를 해결한다.

여기서 `병행 제어`란 여러 트랜잭션이 동시에 수행되더라도 문제 없이 정확한 결과를 얻을 수 있도록 트랜잭션을 제어하는 것을 말한다. 

### 병행 수행 문제 concurrency problems

<img width="488" alt="image" src="https://user-images.githubusercontent.com/51963264/195984311-116ef528-a22b-4504-9a02-3e38bf536f49.png">

병행제어를 하지 않았을 때 일어날 수 있는 문제는 다음과 같다.

- `Dirty Read`

아직 커밋이나 롤백하지 못한 수정 중인 데이터에 접근했을 때 일어날 수 있는 현상

- `Non-Repeatable Read`

 한 트랜잭션 내에서 같은 쿼리를 두번 수행 할 때 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 트랜잭션 결과가 달라지는 현상


- `Phantom Read`

트랜잭션 수행 도중에 새로운 레코드가 삽입되는 것을 허용하기 때문에 나타나는 현상으로 한 트랜잭션 안에서 일정 범위의 레코드를 두번 이상 읽을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상


- `lost update`

트랜잭션이 수행한 데이터 변경 결과를 다른 트랜잭션이 덮어써 연산이 무효화되는 현상

### 로킹 기법

트랜잭션 처리의 순차성을 보장하기 위한 방법으로 트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는(lock) 기법이다.

이를 통해 상호 배제(Mutual Exclusive) 기능을 제공하며, 잠금을 설정한 트랜잭션이 해제(unlock)할 때까지 데이터를 독점적으로 사용할 수 있다.

#### `로킹 단위`

한번에 로킹 할 수 있는 데이터의 크기를 로킹 단위라고 하며 필드(Field), 레코드(Record), 테이블(Table), 파일(File), 데이터베이스(Database) 모두 로킹 단위가 될 수 있다. 

로킹 단위의 크기에 따라 성능의 차이가 발생한다.로킹 단위가 클수록 병행 제어가 단순해지고 관리하기가 편하지만 병행성 수준이 낮아진다.반면 로킹 단위가 작을수록 병행 제어가 복잡해지고 오버헤드가 증가하지만, 병행성 수준이 높아지고 데이터베이스 공유도가 높아진다. 


#### `로킹 규약`

기본적으로 로킹은 lock과 unlock 연산을 사용한다. 로킹 규약은 다음과 같다. 


>1. 트랜잭션 T가 공유 데이터 x를 접근하려면 먼저 lock(x)을 해야 한다.
>2. 공유 데이터를 사용한 T는 반드시 unlock(x)을 해야 한다.
>3. 다른 트랜잭션에 의해 lock(x)가 실행되었다면, 트랜잭션 T는 lock(x)을 실행하지 못한다.
>4. 트랜잭션 T가 lock(x) 한 것을 다른 트랜잭션이 unlock(x)할 수 없다.

#### `한계점`

이러한 로킹 규약에는 제약이 있는데 하나의 트랜잭션만이 공유 데이터를 사용할 수 있는데, 실제로 오직 읽기(read)만 하는 경우에는 동시에 접근해도 문제가 없기 때문에 이런 경우에 효율적이지 못하다.따라서 위와 같은 문제점을 해결하기 위해 사용되는 것이 2단계 로킹 규약이다. 하지만 이것마저도 한계점이 있는데 바로 교착 상태(Dead lock)가 발생할 수 있다는 것이다.

교착상태에 빠지면 트랜잭션들은 작업을 수행하지 못하고 상대가 unlock 연산을 실행해주기를 기다리게 된다.

교착상태를 해결하기 위해서는 처음부터 발생하지 않도록 예방하거나 발생했을 경우 빠른 조치를 취함으로써 해결한다.